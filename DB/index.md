[돌아가기](./README.md)

# Index

RDBMS에서 검색 속도를 높이기 위해 사용하는 기술로 Index(색인)이라고 부른다

테이블의 특정 칼럼을 색인화(별개 파일로 저장)

→ 테이블의 레코드를 full scan하지 않고 색인화 된 index파일을 검색하여 검색 속도를 빠르게 한다

**인덱스는 책을 볼 때 목차를 보고 원하는 내용의 페이지를 찾는 것과 같으며,**

**인덱스가 없다면 책을 처음부터 끝까지 일일이 살펴봐야 하는 것과 같다**

### 트리구조

Index는 Tree구조로 색인화

→ RDBMS에서 사용하는 Index는 Balance Search Tree를 사용

# Index 구성

특정 컬럼에 대한 Index 생성 후 초기 테이블 생성 시  **`FRM`**, **`MYD`**, **`MYI`** 3개의 파일이 만들어진다

- `FRM` → 테이블 구조가 저장되어 있는 파일 (Frame)
- `MYD` → 실제 테이터가 있는 파일
- `MYI` → Index 정보가 들어있는 파일

## MYI 파일

어떤 칼럼에도 인덱스가 없다면, MYI 파일은 비어져 있다

→ 어떤 컬럼에 대해 인덱스 생성 시 MYI 파일에 해당 컬럼 인덱싱 입력(저장)

## SELECT 쿼리

해당 쿼리에서 인덱스를 사용할 수 있다면 테이블 조회가 아니라 MYI 파일의 내용을 검색

→ 인덱스를 사용할 수 없는 쿼리라면 테이블에 대해 Full scan 후 검색

# Index 장점

- 검색과 정렬 속도를 향상 시킨다
- 테이블 행(row; 레코드)의 고유성을 강화시킨다
- primary key는 자동 인덱싱
- 다중 컬럼 인덱스를 사용하면, 하나의 컬럼 값이 같은 레코드도 구분 가능

    (다중 컬럼 인덱스는 최대 10개 컬럼까지 가능)

# Index 단점

- 인덱스로 사용할 수 없는 컬럼(필드)이 존재 가능 (데이터 형식 제한)
- 인덱스를 만들수록 .mdb 파일 크기가 증가
- 사용자에게 있어 한 페이지를 동시에 수정할 수 있는 병행성 감소
- 인덱싱 된 컬럼에 대한 DML(업데이트,추가,삭제) 성능 감소
- 인덱싱이 많아질수록 추가적인 공간 요구됨 (DB의 10% 내외 추가공간)
- 인덱스 생성 시 많은 시간 소요
- 데이터 변경 작업이 잦을 경우 성능이 낮아짐 (인덱스 재작성이 필요할 수 있기 때문)

즉, 어떤 컬럼에 대해 인덱싱을 할 지 테스트하고, 성능과 타협하여 결정할 필요가 있다

(검색  쿼리가 1초 빨라지고, 데이터 행 추가는 2초 느려짐 → 여러 사용자 동시 접근 시 레코드 락 문제 발생 우려)

→ 쿼리 종류 관계 없이 가장 고유한 값을 갖는 컬럼만 인덱싱해야 한다

# Index 목적

검색 속도를 증가시키는 것

SELECT 쿼리(+WHERE, +JOIN)에 인덱스를 사용하고, SELECT 쿼리의 검색 속도를 빠르게 하는 것을 목표

→ DML(DELETE, INSERT, UPDATE) 쿼리에는 해당 사항이 없어 인덱스를 사용하면 더 느려짐

# Index 사용 상황

### Best case

- Where 절에 자주 사용되는 컬럼
- Foreign key 컬럼
- Join에 자주 사용되는 컬럼

### Worst case

- 데이터 중복도가 높은 컬럼
- DML이 잦은 컬럼

# about DML when Index

### INSERT

- index split

    어떤 인덱스 블록을 하나에서 두개로 나누는 현상

    → 인덱스 블록에 여유 공간이 없다면 새로운 데이터 삽입 시,

    새 블록 생성 후 두개의 블록에 인덱스 적절 분배

    ⇒ 성능 상 매우 불리

    - Index split은 새로운 블록을 할당하고 key를 옮기는 작업 수행

        → 모든 수행 과정이 redo에 기록되며 redo가 유발됨

    - Index split이 수행되는 동안, 해당 블록에 대한 DML이 억제됨

### DELETE

- 테이블의 삭제

    데이터가 삭제되고 공간을 반납

- 인덱스의 삭제

    데이터가 남아 있고, 데이터가 사용될 수 없음을 표시

### UPDATE

테이블에 업데이트 발생할 경우,

인덱스에서 먼저 delete 발생 후, 새로운 작업의 insert 연산이 발생

→ delete, insert 연산이 인덱스에 동시 발생하기 때문에 다른 DML보다 더 많은 성능 부하 유발
