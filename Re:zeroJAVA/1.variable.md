[돌아가기](README.md)

# 변수(variable)

변경 가능한, 단 하나의 값을 저장할 수 있는 메모리 상의 공간

# 변수 선언

메모리 상의 공간을 할당 받는 작업

`변수 타입` `변수 이름`;

e.g.,

```jsx
int age;
String name;
float height;
```

### 변수 타입

변수에 저장될 값의 종류를 지정하는 키워드

### 변수 이름

변수를 식별하는 이름

# 변수 초기화

변수 선언과 동시에 초기 값을 설정하는 작업

`변수 타입` `변수 이름` = `값`;

e.g.,

```jsx
int age = 26;
String name = "Lee";
float height = 180.29f;
```

변수로 할당 될 메모리 공간은 여러 프로그램이 공유하는 자원

→ 변수 선언 시, 해당 공간의 쓰레기 값이 남아 있을 수 있으므로 초기화를 통해 공간을 정리한다.

### 콤마 `,` 를 이용한 여러 변수 동시 선언 또는 초기화

변수 타입이 같은 변수들에 한해서, 한 줄에 동시 선언 또는 초기화 가능

**동시 선언**

`변수 타입` `변수A 이름`,  `변수B 이름` ... ;

**동시 초기화**

`변수 타입` `변수A 이름` = `변수A 값`, `변수B 이름` = `변수B 값` ... ;

e.g.,

```jsx
int x, y, z;
String boy = "Lee", girl = "Kim";
float a, b, c, d, e, f, g;
```

# 변수 명명 규칙

### 식별자 (identifier)

`변수 이름`을 포함한, 프로그래밍에서 사용하는 모든 이름

식별자는 같은 영역에서 서로 구분하기 위해 고유한 이름이어야 한다.

### 식별자 생성 규칙 (변수 명명 규칙)

- 대문자와 소문자는 서로 구분되며, 길이 제한은 없다.
- 예약어 사용은 금지한다.
- 숫자로 시작하면 안된다.
- `_`(underscore) , `$` (dollar) 를 제외한 특수 문자 사용은 금지한다.

### 프로그래머 권장 규칙 (필수 X, 그러나 권장됨)

- 클래스 이름의 첫 글자는 대문자로 쓴다.

    e.g., public class Animal

- 여러 단어로 이루어진 이름은 CamelCase(단어의 첫 글자를 대문자로 작성)로 작성한다.

    e.g., StringBuffer

- 상수의 이름은 모든 글자를 대문자로 쓴다.

    e.g., MAX_NUMBER

# 변수 타입

변수에 저장될 값의 종류와 메모리 공간 크기를 지정하는 키워드

값의 종류는 크게 문자와 숫자로 나뉜다. 또, 숫자는 다시 정수와 소수로 나뉜다.

### data

- 문자
- 숫자
    - 정수
    - 소수

## 기본형과 참조형 변수 타입

### 기본형 (primitive type)

실제 값을 저장하는 변수 타입

- 논리(boolean)

    → 1 byte; `true` or `false`

    **왜 1 비트가 아니고 1 바이트 일까?**

    → 자바의 데이터 처리 최소 단위가 byte이기 때문

- 문자(char)

    → 2 byte; 하나의 유니코드(2byte) 문자를 변수에 저장

- 정수(byte, short, int, long)

    byte → 1 byte

    short → 2 byte

    int → 4 byte

    long → 8 byte

- 실수(float, double)

    float → 4 byte

    double → 4byte

### 상수와 리터럴 (constant & literal)

- 상수 (contstant)

    변수처럼 값을 저장하지만, 한번 정한 값을 다른 값으로 변경이 불가능한 공간

    변수 앞에 `final` 키워드 부착

    e.g.,

    ```jsx
    // 변수 (variable)
    String name;
    int age = 26;

    // 상수 (constant)
    final int MAX_AGE = 100;
    ```

    변수와 다르게 상수는 무조건 선언과 동시에 초기화를 진행해야 한다.

- 리터럴 (literal)

    변수와 상수에 저장되는 순수 값들을 지칭하는 용어

    e.g.,

    ```jsx
    // 리터럴 lee
    String name = "lee";

    // 리터럴 100
    final int MAX_AGE = 100;
    ```

### 참조형 (reference type)

어떤 값이 저장되어 있는 객체의 주소를 저장하는 변수 타입

### 참조형 변수 선언

변수 타입으로 클래스의 이름을 사용한다.

`클래스 이름` `변수 이름`;

e.g.,

```jsx
String name; // String 클래스의 변수 name
```

### 참조형 변수 초기화

참조 변수를 선언 하는 것과 동시에 해당 변수가 가리키는 객체를 생성

`클래스 이름` `변수 이름` = new `클래스 이름`();

e.g.,

```jsx
Dog happy = new Dog(); // happy라는 이름의 Dog 클래스 객체를 생성
```

→ `new` 연산자를 사용하면, 어떤 클래스의 객체를 새로 생성할 수 있다.

### 참조형 변수의 크기

JVM의 비트 수에 따라서 참조형 변수의 크기가 변경된다.

- 32bit JVM 의 경우

    → 참조형 변수의 크기: 4 byte

- 64bit JVM 의 경우

    → 참조형 변수의 크기: 8 byte

# 비트(bit)와 바이트(byte)

### 비트 (bit)

컴퓨터가 값을 저장할 수 있는 최소 단위

하나의 비트에 0 또는 1 을 값으로 저장

### 바이트 (byte)

8개의 비트를 묶은 단위

1 byte = 8 bit

### 워드 (word)

CPU가 한 번에 처리할 수 있는 단위

- 32 bit CPU 의 경우

    1 word = 4 byte = 32 bit

- 64 bit CPU 의 경우

    1 word = 8 byte = 64 bit

## **n 개의 비트가 표현할 수 있는 10 진수**

- 값의 개수

    → 2^n 개

- 값의 범위

    → 0 ~ (2^n - 1)

# Unicode

전 세계의 모든 문자를 하나의 통일된 문자 집합으로 표현하려고 한 것

→ 보충 문자(21bit)를 사용하기 위해서는 int 타입을 사용해야 한다.

### 유니코드 문자 셋(또는 캐릭터 셋)

우선적으로 유니코드에 포함 시키려는 문자들의 집합

### 유니코드 인코딩

유니코드 문자 셋에 번호를 붙인 것

UTF-8, UTF-16, UTF-32 등등...

**→ 자바가 사용하는 유니코드 인코딩은 UTF-16**

- UTF-8

    하나의 문자를 1 ~ 4 byte의 가변 크기로 표현

- UTF-16

    모든 문자를 2 byte의 고정 크기로 표현

## 정수 타입의 선택 기준 (byte, short, int, long)

- 정수 타입의 변수를 선언할 때는 `int` 타입을 사용

    → JVM의 피연산자 스택(operand stack)은 피연산자를 4 byte 단위로 저장한다. 

    short, byte 변수는 계산 전에 4 byte로 변환되기 때문에 속도가 느려진다.

- `int`의 범위를 넘어서는 수를 다룰 때는 `long`을 사용
- 저장 공간을 절약하는 것이 속도보다 우선 시 될 때 `byte` 나 `short` 를 사용

# Overflow

변수 타입이 표현할 수 있는 값의 범위를 넘어가 다른 결과를 얻는 상황

### overflow의 결과

- 최대 값 + 1 = 최소 값
- 최소 값 - 1 = 최대 값

### 부호에 따른 정수의 overflow 발생 조건

- 부호가 없는 정수

    2진수로 0이 될 때 발생

    e.g., `1111` → `0000` (15 → 0)

- 부호가 있는 정수

    2진수로 부호 비트가 0에서 1로 바뀔 때 발생

    e.g., `0111` → `1000` (7 → -8)

## 실수 타입 overflow

실수 타입의 변수에서 overflow가 발생하면 변수의 값은 무한대 (infinity)

### Underflow

실수 타입의 변수에서 표현할 수 없는 아주 작은(최소 값보다 더 작은) 값을 얻게 되는 상황

→ 이때 변수의 값은 0이 된다.

# 형 변환 (casting)

변수 또는 상수의 타입을 다른 타입으로 변환 하는 것

→ `boolean` 을 제외한 다른 기본형 변수 타입 끼리 서로 형 반환이 가능

→ 기본형과 참조형 변수 사이의 캐스팅은 불가능

### 캐스팅 방법

`(타입)` `피연산자` ;

e.g.,

```jsx
double x = 3.14;
int y = (int)x; // int casting
```

→ 캐스팅은 기존의 변환 대상이 되는 변수의 값을 변경시키지 않는다.

### 값 손실 (loss of data)

큰 타입의 데이터를 작은 타입의 데이터로 캐스팅 할 경우, 값에 손실이 생김

### 실수 타입 → 정수 타입 캐스팅

소수점 자리를 버린다. (반올림이 아니다.)

e.g., (int)1.6666 → 1

## 자동 캐스팅

캐스팅을 생략할 때, 컴파일러가 생략된 캐스팅을 자동적으로 추가하는 것

e.g.,

```jsx
float f = 1234; // float f = (float)1234;
```

### 산술 변환

연산 과정에서 먼저 타입을 (자동 캐스팅으로) 일치 시킨 뒤 연산을 수행하는 작업

e.g.,

```jsx
double x = 1.23 + 2; // double x = 1.23 + (double)2;
```

→ 두 타입 중 표현 범위가 더 넓은 타입으로 캐스팅을 수행한다.

### 자동 캐스팅 규칙

기존의 값을 최대한 보존할 수 있는 타입으로 자동 캐스팅

즉, 표현 범위가 더 넓은 타입으로 캐스팅 한다.

`byte` → `short`, `char` → `int` → `long` → `float` → `double`

- `float` 의 경우, `long` 보다 바이트 크기가 작지만, 숫자를 표현하는 방식이 다르므로 표현 범위가 더 넓다.
- `short` 와 `char` 는 같은 2 byte이지만, 표현 범위가 다르므로 값 손실이 무조건 발생

    → 그러므로 `short` 와 `char` 간의 자동 캐스팅은 이루어지지 않는다.

### 자동 캐스팅 조건

1. boolean을 제외한 7가지 기본 타입은 서로 캐스팅 가능
2. 기본 타입과 참조 타입은 서로 캐스팅 불가능
3. 서로 다른 타입 변수의 연산에서 명시적 캐스팅이 원칙이지만,
작은 범위 타입에서 큰 범위 타입으로 캐스팅은 생략 가능
