[돌아가기](./README.md)
# 그래프

정점(Node)과 간선(Edge)로 구성하는 자료구조

### 정점(Node)

그래프 자료구조에 의미있는 값을 저장하는 구성요소

### 간선(Edge)

정점(Node)들을 연결하는 선

유향(단방향), 무향(양방향)으로 나뉠 수 있다

## 무향 그래프(Undirected Graph)

간선에 방향성이 없는 그래프

```jsx
// 정점
V = { 서울, 대구, 부산 }

// 간선
E = { (서울, 대구), (서울, 부산), (대구, 부산) }
```

→ 간선을 나타내는 (from, to) 쌍은 from 정점과 to 정점을 연결한다

## 유향 그래프(Directed Graph)

간선에 방향성이 있는 그래프

```jsx
// 정점
V = { 서울, 대구, 부산 }

// 간선
E = { (서울, 대구), (대구, 서울), (서울, 부산), (부산, 서울) }
```

→ 간선을 나타내는 (from, to) 상은 from에서 to로 향하는 방향을 가진 간선이다

# 차수 (Degree)

각 정점을 기준으로 해당 정점에 연결된 간선 개수

### Indegree & Outdegree

- Indegree

    유향그래프에서, 각 정점으로 들어오는 방향의 간선 개수

- Outdegree

    유향그래프에서, 각 정점에서 밖으로 나가는 방향의 간선 개수

# 가중치 그래프(Weight Graph)

간선(Edge)에 의미있는 수치(가중치 정보)를 부여한 그래프

# 부분 그래프(Sub Graph)

어떤 그래프의 일부분을 나타내는 그래프

# 그래프 구현

### 인접 행렬 (adjacent matrix)

그래프를 구성하는 N개의 정점에 대해 N x N 정방 행렬을 이용하는 방법

N x N 정방 행렬에서 각 원소 값을 통해 각 정점들을 연결하는 간선의 유무를 알 수 있다

→ 시간 복잡도 : O(1)

→ 공간 복잡도 : O(N^2)

밀집 그래프(Dense Graph; 간선이 많은 그래프)를 표현할 때 유용

### 인접 리스트 (adjacent list)

그래프를 구성하는 N개의 정점에 대한 각 N개의 리스트를 이용하는 방법

각 N개의 리스트에는 각 정점과 관련된 간선의 정보가 삽입된다

→ 시간 복잡도 : O(1) ~ O(E)

→ 공간 복잡도 : O(N + E)

희소 그래프(Sparse Graph; 간선이 적은 그래프)를 표현할 때 유용

# 그래프 탐색

### DFS

모든 노드의 방문을 쉽게 구할 수 있다 → O(N+E)

### BFS

어떤 목적지까지의 최단 경로를 구할 수 있다 → O(N+E)

# MST (Minimun Spanning Tree)

그래프의 spanning tree 중 간선의 가중치 합이 최소가 되는 Spanning Tree

**Spanning Tree?**

→ 그래프의 모든 정점을 cycle 없이 전부 방문한 Tree

### Kruskal Algorithm

MST를 찾는 알고리즘

- 동작순서
    1. 그래프에서 간선을 제외한 정점들만 배치한다
    2. 가장 가중치가 낮은 순서대로 간선을 하나씩 배치한다
    (단, cycle이 생기지 않을 때만 배치를 확정한다)
    3. 모든 정점을 연결한 Spanning Tree가 완성되면 종료한다
    (혹은, Spanning Tree가 완성되지 않더라도, 모든 간선에 대한 검토가 끝나면 종료)
- Cycle 검토
    - Union-Find 방법
    - set-id 방법

        → 각 정점에 `set-id`를 부여; 

        정점들을 연결할 때마다 각 정점의 `set-id` 를 비교하여 `set-id` 의 개수가 더 큰 `set-id` 로 통일

        e.g., `서울` 정점과 `부산` 정점을 연결할 때, 

        `서울`의 `set-id`는 1이고 이  `set-id == 1` 의 개수는 5개, 

        `부산`의 `set-id`는 2이고 이 `set-id == 2` 의 개수는 2개라고 가정한다면,

        `서울`과 `부산` 의 `set-id` 는 1로 통일시키고 `set-id == 1` 의 개수는 7개가 된다

- 시간 복잡도
    1. 가중치를 기준으로 간선 내림차순 정렬

        → O(E log E)

    2. cycle 체크 및 set-id 일치

        → O(E + N log N)

### Prim Algorithm

MST를 찾는 알고리즘

- 동작순서
    1. 그래프 중 임의의 정점을 seed로 선정 후 `방문한 정점 집합`에 포함
    2. `방문한 정점 집합`에 속한 정점들과 외부로 연결된 간선들 중 가장 가중치가 작은 간선 선택하여 연결
    3. 그 간선으로 연결된 새로운 정점도 `방문한 정점 집합`에 포함
    4. 그래프의 모든 정점이 `방문한 정점 집합`에 포함될 때까지 2 ~ 3 반복
- 시간 복잡도

    → O (E log N)
