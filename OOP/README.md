# OOP?

Object Oriented Programming (객체 지향 프로그래밍)

프로그래밍 방법 중 하나

개발에 필요한 데이터을 추상화시켜 상태(State)와 행위(Behave)를 가진 객체로 정의

객체들 사이의 상호작용을 통해서 프로그램의 동작 로직을 구성 (현실 세계의 동작 원리로부터 영감을 얻음)

절차 지향 프로그래밍(Procedural Programming)과 곧 잘 비교됨

- PP ?

    작성된 코드를 위에서 아래 방향으로 순차적인 처리하는 프로그래밍 방법

    - 장점

        컴퓨터의 처리 순서와 유사해 실행속도가 빠름

    - 단점

        유지 보수의 어려움 (특히, 프로젝트의 스케일이 커지면 스파게티 코드가 됨)

        실행 순서가 정해져 있어, 코드의 순서가 실행 결과에 영향을 미침

        디버깅의 어려움

- PP와 OOP의 차이점

    둘은 서로 반대되는 개념이 아님!!

    PP는 순차적으로 실행되고, OOP 역시 순차적으로 실행됨

    단지 로직의 구현에 있어서 무엇을 초점에 두고 구현하느냐의 차이만 존재

    - PP

        데이터를 중심으로 함수를 구현

    - OOP

        기능을 중심으로 메소드를 구현

# 등장 계기

옛날과는 달리, 시간이 지남에 따라 하드웨어의 발전 속도가 소프트웨어의 발전 속도를 못따라가게 됨

객체지향 프로그래밍은 기능별로 묶어서 모듈화하고 재사용함 → 하드웨어의 중복 연산을 방지하여 성능 개선

# 특징

1. 캡슐화 (Encapsulation)

    관련된 데이터와 코드를 한 곳에 모아서 분류하는 것

    변수와 함수가 코드 전체에 걸쳐 분산되어 있으면 코드를 재활용(유지 보수 및 확장)하는 것이 어려움

    → 캡슐화를 통해 관련된 데이터와 기능의 재활용이 용이해짐

    - 정보 은닉

        데이터를 캡슐의 내부로 감추고, 메소드를 통해서만 외부 세계와 상호작용함

        (Python의 경우, 클래스를 통한 캡슐화로 OOP가 가능하지만 정보 은닉은 제공하지 않음)

        (Java의 경우, private과 같은 키워드를 통해 클래스 내의 정보 은닉이 가능)

        → 즉, 캡슐화가 무조건 정보 은닉을 보장하는 것은 아님

        → 캡슐화를 통해 정보 은닉의 장점을 가질 수 있다는 것이 포인트

2. 상속 (Inheritance)

    이미 정의된 어떤 클래스(캡슐화)의 특성을 물려받는 것

    기존 속성 및 기능을 변경하거나, 추가하여 새로운 클래스로 정의

    상속은 캡슐화를 유지하면서, 기존 클래스의 재사용을 용이하게 해줌

3. 다형성 (Polymorphism)

    한 이름이 상황에 따라 여러 의미로 해석되도록 하는 기법

    개념적으로 동일한 작업을 수행하는 함수들이 같은 이름을 갖는 것을 통해 코드가 간단해짐

    - Overriding

        기존의 클래스에서 상속받은 메소드를 재정의하는 것

    - Overloading

        이름은 같지만, 입력 매개 변수의 타입과 개수를 다르게 설정해서 다양한 함수를 호출하는 것

# 장점

- 코드의 재사용
- PP보다 쉬운 구조와 간편한 코딩
- 유지보수와 확장의 쉬움
- 데이터 모델링을 할때 객체와의 맵핑이 수월하여, 요구사항을 보다 명확하게 파악 가능

# 단점

- PP보다 느린 처리 속도
- 설계에 필요한 소요 시간이 큼
- 객체가 변수를 통해 상태를 가짐

    → 예측할 수 없는 상태가 되면 애플리케이션의 버그를 초래할 수 있음 (함수형 프로그래밍의 각광)

# 객체 지향적 설계 원칙

1. SRP (Single Responsible Principle / 단일 책임 원칙)

    클래스는 하나의 책임을 가짐

    클래스를 변경하는 이유는 단 한가지일 것

2. OCP (Open-Closed Principle / 개방-폐쇠 원칙)

    확장에는 열려있고, 변경에는 닫혀 있을 것

3. LSP (Liskov Subsitution Principle / 리스코브 치환 원칙)

    상위 타입 객체를 하위 타입에 치환할 때, 상위 타입을 요구하는 프로그램은 문제가 없을 것

4. ISP (Interface Segregation Principle / 인터페이스 분리 원칙)

    인터페이스는 사용자를 기준으로 분리할 것

5. DIP (Dependency Inversion Principle / 의존성 역전의 원칙)

    고수준 모듈은 저수준 모듈에 의존하지 말 것
