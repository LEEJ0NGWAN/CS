[한국어로 보기](./README.md)

# オブジェクト指向プログラミング
Object Oriented Programming

**"データをオブジェクトに定義し、オブジェクトの相互作用を使ってプログラムを作る方法"**

<br/>
<br/>

## オブジェクト (Object)

データの抽象化; 状態(State)と行為(Behave)を持つ物

### 現実世界からのインスピレーション

→ オブジェクトの相互作用でプログラムロジックを構成

<br/>
<br/>

# 手続き型プログラミング vs オブジェクト指向プログラミング

## 手続き型プログラミング (Procedural Programming)

"**順番が決めた作業(routine；procedure)の連続でプログラムを作る方法"**

<br/>

- メリット

    コンピューターの処理ルーチンと類似で、実行速度が速い

- デメリット

    メンテナンスが難しい(特に,プロジェクトのスケールが大きくなったらスパゲッティコードに成る)

    コードの実行順序が結果に影響を与える

    デバッグの難

<br/>

## PPとOOPの違い

プログラムの実現にあって、何処に重点を置くのか

### PP

→ データ変化を中心に関数を実現

### OOP

→ 機能を中心にメソッドを実現

<br/>
<br/>

# OOP登場切っ掛け

時間が過ぎってハードウェアの発展速度がソフトウェアの発展速度を追い付くのができなくなる

オブジェクト指向プログラミングは機能を一所に集めて、モジュール化および再利用 → ハードウェアの重複計算を防ぐことで性能を高める

<br/>
<br/>

# OOP特徴

## 1. カプセル化(Encapsulation)

"**関わるデータとコードを一所に集めること"**

変数と関数がコード全体に広かったら,コードを再利用(メンテナンスおよび拡張)するのことが難しい

→ カプセル化でデータと機能の再利用性増加

### 情報隠蔽

"**データをカプセルの中で隠して、メソッドを通じて外部世界と相互作用"**

(Pythonの場合、カプセル化でOOPができるが　情報隠蔽はできない)

(Javaの場合、privateみたいなキーワードを使ってクラス中にある情報を隠せることができる)

→ つまり、カプセル化が絶対的に情報隠蔽を保証するのでは無いけど、情報隠蔽のメリットを持つことができる

## 2. 相続(Inheritance)

"**すでに定義したクラス(カプセル化)の特性を相続すること"**

既存の属性および機能を変えたり追加して新しいクラスに作る

→ 相続はカプセル化を維持し、既存クラスを再利用することに役に立つ

## 3. 多形性(Polymorphism)

"**状況によって色々な意味に解析すること"**

概念的に同じ(類似な)関数に同じ名前をつけることでコードをシンプルにまとめる

### Overriding

既存クラスから相続したメソッドを改めて定義すること

### Overloading

名前は同じだけど、入力する引数タイプと個数を別々に設定し色々な関数を呼び出すこと

# OOPメリット

- コードの再利用
- PPより理解安い仕組みとシンプルなコーディング
- メンタナンス、拡張の安い
- データモデリングをする時オブジェクトとデータのマッピングが安い

    → 要求事項をもっと明確に理解できる

# OOPデメリット

- PPより遅い処理速度
- 設計に時間がかかりすぎる
- オブジェクトが変数を通じて状態を持つ

    → 予測できない状態になれば、バグがあるかも(関数型プログラミングの再発見)
    


# オブジェクト指向的設計原則(SOLID)

1. SRP (Single Responsible Principle / 単一責任の原則)

    クラスは一つの責任を持つ

    クラスを変更する理由はただ一つであること

2. OCP (Open-Closed Principle / 解放閉鎖の原則)

    拡張に開き、修正には閉じること

3. LSP (Liskov Subsitution Principle / リスコフの置換原則)

    スーパークラスは、そのサブクラスで代用可能でなければならないこと

4. ISP (Interface Segregation Principle / インタフェース分離の原則)

    インタフェースはユーザーを中心に分離すること

5. DIP (Dependency Inversion Principle / 依存性逆転の原則)

    高水準モジュールは低水準モジュールに依存してはならないこと
    （両者は、抽象化に依存するべきである）
