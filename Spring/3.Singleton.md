[돌아가기](./README.md)

# 애초에

스프링 개발 계기는 기업용 온라인 서비스 기술 지원을 위함

→ 대부분 스프링 애플리케이션은 웹 애플리케이션

근데 웹 애플리케이션은 많은 고객이 동시에 요청하는 애플리케이션

### 스프링 없는 순수 DI 컨테이너

→ 고객 요청마다 새로운 객체 계속 생성하므로 메모리 및 비용 낭비 심함

# 해결방안

해당 인스턴스가 1개만 생성되고, 공유되도록 설계

→ **싱글톤 패턴**

# 싱글톤 패턴

클래스 인스턴스가 1개만 생성되도록 보장하는 디자인 패턴

인스턴스가 2개 이상이 되지 않도록 방지

⇒ private 생성자를 이용하여 외부에서 new 키워드로 생성하지 못하도록 한다

```jsx
public class Something {

		// 인스턴스 생성
		private static final Something instace = new Something();

		// priavte 키워드를 통한 외부 new 방지
		private Something() {}

		// 인스턴스 반환
		public Something getInstace() {
				return instance;
		}
}
```

싱글톤 패턴을 통해 클래스 인스턴스를 재사용

## 싱글톤 패턴 문제점

- 구현 코드 번거로움
- 의존 관계에서 클라이언트가 하위 타입에 의존 → DIP 위반
- 하위 타입 의존에 따른 OCP 위반 가능성
- 테스트 번거로움
- 내부 속성 변경 및 초기화의 어려움
- priavte 생성자는 자식 클래스 만들기 어려움

→ 유연성이 굉장히 떨어지며, 안티패턴으로 불림

# 싱글톤 컨테이너

싱글톤 패턴의 문제점을 해결하면서 클래스 인스턴스를 1개만 생성 및 관리

스프링 빈은 싱글톤으로 관리되는 객체

### 싱글톤 레지스트리

싱글톤 객체를 생성하고 관리하는 기능

스프링 컨테이너는 싱글톤 컨테이너의 역할을 수행

→ 싱글톤 패턴의 단점을 보완하고 DIP, OCP, private 키워드로부터 자유로운 싱글톤 사용 가능

⇒ 요청이 올 때 마다 객체를 생성하지 않고, 이미 만들어진 싱글톤 객체를 공유하며 효율적 재사용

# 싱글톤 방식의 주의점

여러 클라이언트가 하나의 싱글톤 인스턴스를 공유하기 때문에 stateful하게 설계해서는 안된다

### 싱글톤 인스턴스 stateless 설계

- 의존적인 필드 X
- 임의로 값 변경 가능 필드 X
- 읽기 지향 설계
- 필드 대신 공유될 수 없는 지역변수, 파라미터, ThreadLocal 등을 사용

→ 싱글톤 인스턴스(스프링 빈) 내부에 공유되는 값을 설정하면 큰 장애 발생 유도함

# @Configuration

@Bean으로 등록하는 객체는 싱글톤으로 관리하게 해줌

스프링은 바이트 코드를 조작하는 라이브러리를 사용하여 

`@Configuration`이 붙은 설정 클래스를 상속하는 다른 클래스를 생성하며 싱글톤 보장 처리

즉, `@Configuration` 가 붙지 않으면 내부에 등록하는 `@Bean` 은 정상적으로 동작하지만,

싱글톤 보장을 할 수 없게 됨

→ `@Autowired` 를 이용하여 극복하는 방법도 있긴 있으나 걍 `@Configuration`을 쓰는게 좋음
