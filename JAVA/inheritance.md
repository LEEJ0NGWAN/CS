[돌아가기](./README.md)

# **상속 (Inheritance)**

OOP의 대표 특징 중 하나

어떤 클래스의 맴버 변수와 메소드를 받는 다른 클래스는 해당 클래스를 상속 받는다고 표현

상속 관계를 `부모-자식` 또는 `상위-하위` 관계로 설명

하나의 부모는 여러 자식을 가질 수 있고, 그 부모는 또 다른 부모의 자식일 수도 있음

### **상속 받지 않는 경우**

모든 클래스에 대해, 부모가 없는 경우 자동으로 `java.lang.Object`를 상속

→ 컴파일러가 자동으로 `Object` 상속 처리

### **단일 상속**

자바는 단 하나의 클래스를 상속받을 수 있다 (interface는 여러개 가능)

→ 여러 클래스를 상속받을 경우, 클래스 변수가 겹칠 수 있는 중복 문제와 같은 복잡한 오류가 발생할 수 있기 때문

Object 클래스를 제외한 모든 클래스는 부모가 있다

# **디폴트**

### **import java.lang.*;**

기본으로 추가 되어 있다

### **extends**

상속 클래스가 없는 경우, `java.lang.Object` 자동 상속 (by 컴파일러)

### **기본 생성자**

커스텀 생성자 정의가 없는 경우, public Class() {} 형태의 빈 생성자 자동 생성 (by 컴파일러)

# **Default vs Protected**

### **Default**

기본 접근 제어자 → 동일 패키지 내에서 접근을 허용

### **Protected**

동일 패키지와 패키지가 같지 않더라도 상속 받은 클래스에 대해 접근을 허용

# **this vs super**

### **this**

자기 자신을 가리키는 키워드

→ this 의 경우, 부모와 자식 내부에 중복된 맴버 변수가 있을 수 있으므로 사용에 주의가 필요

### **super**

부모 객체를 가리키는 키워드

super() 를 통해 생성자 내부에서 부모의 생성자 호출 가능

자식 기본 생성자는 부모의 생성자를 별도 호출하지 않으면, 부모의 기본 생성자 자동 호출

→ 기본 생성자가 없으면 호출 못함; 즉, 웬만하면 기본생성자를 명시적으로 만들어주는게 좋다

### **주의**

생성자 내부에서 super() 는 **항상 첫번째 줄**에 위치해야함!

# **클래스와 인터페이스**

### **클래스**

객체에 대한 틀, 정의

### **인터페이스**

클래스가 지녀야 하는 책임, 방법, 약속...

→ 구현과 사용을 분리하는 것을 통해 결합도를 낮춘다

### **추상 메소드**

구현부가 없는 메소드 → 선언만이 존재

`abstract` 키워드를 이용한다

`abstract void foo(); // 추상 메소드`

# **상속 종류**

### **상속**

부모로부터 물려 받은 내용 일부를 수정 및 확장하는 것

## **클래스 상속 (구현 상속)**

- 일반화 관계 (generalization)
- 단일 상속 (죽음의 다이아몬드 문제 방지를 위해)

### **Concrete Class 상속**

모든 메소드 구현이 된 클래스를 상속

→ 메소드 오버라이딩 선택

### **Abstract Class 상속**

`new` 를 통해 인스턴스 생성이 불가능한 추상 클래스를 상속

- 추상 메소드가 있는 추상 클래스 상속

    → 메소드 오버라이딩 필수

- 추상 메소드가 없는 추상 클래스 상속

    → 메소드 오버라이딩 선택

## **인터페이스 상속**

- 실현 관계 (realization)
- 다중 상속 가능

### **인터페이스**

추상 메소드와 상수로 구성 (Java8 부터 static&default method 사용가능)

→ 메소드 오버라이딩 필수

# **상속 이유**

- 코드의 재사용성
- 개발 시간 감소
- 개발 비용 절감

# **상속 단점**

- 강한 결합도 (유지보수 어려움)
- 너무 깊은 상속트리 → 슈퍼 인스턴스가 많아짐
