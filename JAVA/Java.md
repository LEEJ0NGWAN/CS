[돌아가기](./README.md)

[日本語で見る](./Java-jp.md)

# Java

운영체제에 독립적으로 동작하는 객체 지향 프로그래밍 언어

# 특징

## 운영체제 독립성

디바이스 상관 없이 JVM을 통해서 어떤 환경에서도 한번 컴파일 된 자바 애플리케이션을 실행할 수 있다

각 운영체제에 알맞는 JVM이 설치 되어 있다면, 기존 프로그램처럼 플랫폼에 따른 별도의 변경을 하지 않고, 한번 컴파일된 자바 응용 프로그램을 실행할 수 있다.

### Write Once Run Anytime

한번 바이트 코드로 컴파일되면, 어떤 OS에도 국한되지 않고 해석될 수 있다

→ 디바이스 상관 없이 JVM을 통해서 어떤 환경에서도 자바 애플리케이션을 실행

## 객체 지향 언어

자바는 상속, 캡슐화, 다형성이 잘 적용된 순수 객체 지향 언어다.

## 자동 메모리 관리 (Garbage Collection)

자바에는 가비지컬렉터(Garbage collector)가 있는데, 이 가비지컬렉터는 메모리를 자동으로 관리해준다.

프로그래머가 메모리를 관리할 일이 없어지고, 로직 개발에 집중할 수 있도록 도와준다.

## 네트워크 및 분산 처리

자바는 인터넷과 대규모 분산 환경을 고려해서 탄생한 언어로, 네트워크 프로그래밍 라이브러리(Java API)가 제공된다.

## 멀티쓰레드

운영체제 별로 구현 방법과는 상관 없이, 자바 차원에서 Java API를 통해서 멀티쓰레드가 제공됨

## 동적 로딩

프로그램 실행 시 필요한 시점에 따른 일부 클래스가 동적으로 로딩됨

또, 일부 클래스 변경 시에도 전체 애플리케이션의 컴파일이 요구되지 않음

→ 비교적 적은 작업으로 변경 사항의 처리가 가능한 유연한 애플리케이션 제작 가능

## JVM(Java Virtual Machine)

자바 애플리케이션을 실행하기 위한 가상 머신

### 단점

기존 애플리케이션과 달리, 컴파일된 자바 파일이 실행 시에 해석(interpret)되기 때문에 속도가 약간 느림

→ 바이트 코드(컴파일된 자바 코드)를 하드웨어의 기계어로 바로 변환 시켜주는 JIT 컴파일러 및 최적화 기술로 어느정도 개선됨

## **JDK JRE**

### **JDK**

자바 애플리케이션을 개발하기 위한 킷으로 컴파일 기능을 지원

### **JRE**

컴파일된 바이트 코드의 실행을 위한 런타임 환경 및 JVM 지원

# 동작 순서

`Hello.java` → `Hello.class` → `"Hello world"`

1. 컴파일

    java 파일을 컴파일 후, class 파일 생성 (javac 이용)

2. 실행

    생성된 파일을 실행 (java 이용)

# 소스 파일 작성

## .java = class

java 소스 파일의 이름과 일치하는 클래스가 해당 소스 파일 안에 포함되어야 한다.

## 1 public class per .java

하나의 소스 파일 당 최대 하나의 public class를 가진다.

→ public class가 하나도 없다면, 소스 파일의 이름과 class의 이름만 확인하면 된다.

### 특징

하나의 자바 소스 파일에 여러 class를 만들어도, 컴파일 시 클래스 파일(.class)은 클래스 당 하나씩 생성된다.

# **Garbage Collector**

### **minor GC**

힙 메모리 영역에서 Eden과 Survive 영역의 객체들 관리

- Eden

    새로 생성되는 객체들이 관리되는 영역

- Survive0 & Survive1

    Eden 정리 작업 때, 자주 사용되는 객체들이 이전되는 영역

→ Survive0 과 Survive1은 swaping으로 번갈아서 사용됨

### **major GC**

힙 메모리 영역에서 old 영역의 객체들 관리

→ 몇 번의 minor GC에도 살아있는 객체는 majorGC가 관리하는 old 영역으로 이전

# **참조값 사용 이유**

참조값은 테이블을 통해 객체의 메모리 주소와 1:1 맵핑

객체의 메모리 주소는 GC의 과정을 거치면서 자주 메모리가 이전되기 때문에 고정된 참조값 이용 필요
